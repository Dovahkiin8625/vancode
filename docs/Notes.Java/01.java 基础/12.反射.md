---
title: java 反射
date: 2022-02-09 14:28:16
permalink: /pages/aa3d4f2190dab077
categories:
  - Java
  - java 基础
tags:
  - 特性
author:
  name: Vance L
  link: https://github.com/Dovahkiin8625

---



> 文章示例代码 [源码](https://github.com/Dovahkiin8625/javaLearn/tree/master/JavaBasic/src/main/java/com/Reflection)

# Java 基础 - 反射 <font color="#999">Java Reflection </font>

[[TOC]]

## 1 简介

反射就是把Java类中的各个成分映射成一个个的java对象。

### 1.1 Why we use reflection in Java?

> Oracle关于反射的介绍[Using Java Reflection](https://www.oracle.com/technical-resources/articles/java/javareflection.html)
> 
> Reflection is a feature in the Java programming language. It allows an executing Java program to examine or "introspect" upon itself, and manipulate internal properties of the program. For example, it's possible for a Java class to obtain the names of all its members and display them.

它允许执行的Java程序检查自己，并操作程序的内部属性。

## 2 使用

`Java.lang.Class`和`java.lang.reflect`对Java的反射<font color="#999">Reflection</font>进行了很好的支持。

### 2.1 一个栗子:chestnut:

:page_facing_up: Code:

```java
public class SimpleReflectionTest {
    @Test
    public void testReflectionSimpleExample(){
        try {
            // obtain a java.lang.Class object for the class "ava.util.Stack"
            Class c = Class.forName("java.util.Stack");
            // to get a list of all the methods declared by the class.
            Method m[] = c.getDeclaredMethods();
            // print them all
            for (int i = 0; i < m.length; i++)
                System.out.println(m[i].toString());
        }
        catch (Throwable e) {
            System.err.println(e);
        }
    }
}
```

:heavy_check_mark: Output:

```
public boolean java.util.Stack.empty()
public synchronized java.lang.Object java.util.Stack.peek()
public synchronized int java.util.Stack.search(java.lang.Object)
public java.lang.Object java.util.Stack.push(java.lang.Object)
public synchronized java.lang.Object java.util.Stack.pop()
```

该程序使用`class.forName`加载指定类，然后调用`getDeclaredMethods`方法获取该类定义的所有方法，`java.lang.reflect.Method`是Java的类方法类 <font color="#999">A class representing a single class method</font>

### 2.2 使用反射的基本流程

通过上述例子，已经简单了解反射的最简单使用，下面介绍反射的使用步骤:

1. 获取所要操作的类的`java.lang.Class`对象 `java.lang.Class`用于在java运行时代表类和接口。
   
   > 一种获取`Class`对象的方法
   > 
   > * 使用`Class.forName`方法，如获取`String`类的`Class`对象：`Class c = Class.forName("java.lang.String")`
   > * 获取基本类型的`Class`类：`Class c = int.class`或者`Class c = Integer.TYPE`。后者通过访问基本数据类型的封装类的`TYPE`字段获取`Class`类

2. 调用方法，如`getDeclaredMethods`得到类的方法列表。

3. 使用反射的API操作类对象的信息。

## 3 Class 类

在类加载的时候，jvm会创建一个class对象

class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种

**`Class` 类方法**

| 方法名               | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `forName()`          | **静态方法**(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。(2)为了产生Class引用，forName()立即就进行了初始化。 |
| `getName()`          | 取全限定的类名(包括包名)，即类的完整名字。                   |
| `getSimpleName()`    | 获取类名(不包括包名)                                         |
| `getCanonicalName()` | 获取全限定的类名(包括包名)                                   |
| `isInterface()`      | 判断Class对象是否是表示一个接口                              |
| `getInterfaces()`    | 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。 |
| `getSupercalss()`    | 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。 |
| `newInstance()`      | 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。注意：该方法在Java9以上被弃用，替代方法`getConstructor().newInstance()` |

> 获取字段、构造函数、方法的方法请参考后续`Constructor` 类、`Feild`类、`Method`类。

### 3.1 示例用类

`Class`类使用方法举例的示例类代码,后续`Class`类使用的测试代码都基于此。

:page_facing_up: Code:

```java
// Class类相关方法测试示例类
interface T1{}
interface T2{}
class  Organism { public int var;}
class Animal extends Organism{
    // Permission access modifier var
    private int aVarPrivate;
    protected int aVarProtected;
    int aVarDefault;
    public int aVarPublic;
    // static var
    private int aVarStaticPrivate;
    protected int aVarStaticProtected;
    int aVarStaticDefault;
    public int aVarStaticPublic;
}
class Cat extends Animal implements T1,T2{
    class Head{ }
    // Permission access modifier var
    private int cVarPrivate;
    protected int cVarProtected;
    int cVarDefault;
    public int cVarPublic;
    // static var
    private int cVarStaticPrivate;
    protected int cVarStaticProtected;
    int cVarStaticDefault;
    public int cVarStaticPublic;
    // constructor
    public Cat() {}
    public Cat(int cVarPrivate, int cVarStaticPrivate) {
        this.cVarPrivate = cVarPrivate;
        this.cVarStaticPrivate = cVarStaticPrivate;
    }
    // get set
    public int getcVarPrivate() { return cVarPrivate; }
    public void setcVarPrivate(int cVarPrivate) { this.cVarPrivate = cVarPrivate; }
    public int getcVarStaticPrivate() { return cVarStaticPrivate; }
    public void setcVarStaticPrivate(int cVarStaticPrivate) { this.cVarStaticPrivate = cVarStaticPrivate; }
}
```

### 3.2 获取`Class`对象：

* 根据类名： `类名.class`
* 根据对象： `对象.getClass()`
* 根据全限定类名： `Class.forName(全限定类名)`

:page_facing_up: Code:

```java
public class ReflectionClassDemo {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Test // 获取Class测试
    public void testReflectionClass() throws ClassNotFoundException {
        logger.info("根据类名获取Class:\t"+Cat.class);
        logger.info("根据对象获取Class:\t"+new Cat().getClass());
        logger.info("根据全限定类名获取Class:\t"+Class.forName("com.Reflection.Cat"));
    }
}
```

:heavy_check_mark: Output:

```
2022-03-18 14:32:47 - INFO - 根据类名获取Class:	class com.Reflection.Cat
2022-03-18 14:32:47 - INFO - 根据对象获取Class:	class com.Reflection.Cat
2022-03-18 14:32:47 - INFO - 根据全限定类名获取Class:	class com.Reflection.Cat
```



### 3.3 获取类名

* `getCanonicalName() `是获取所传类从java语言规范定义的格式输出。
* `getName() `是返回[实体类](https://so.csdn.net/so/search?q=实体类&spm=1001.2101.3001.7020)型名称
* `getSimpleName()`返回从源代码中返回实例的名称。

:page_facing_up: Code:

```java
public class ReflectionClassDemo {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Test // Class 类相关方法测试
    public void testClassGetClassName(){
        // 获取类名的三种方法
        logger.info("-------------- 普通类 --------------");
        Class normal = Cat.class;
        logger.info(normal.getCanonicalName());
        logger.info(normal.getName());
        logger.info(normal.getSimpleName());

        logger.info("-------------- 内部类 --------------");
        Class inner = Cat.Head.class;
        logger.info(inner.getCanonicalName());
        logger.info(inner.getName());
        logger.info(inner.getSimpleName());

        logger.info("-------------- 匿名类 --------------");
        Class anonymous = new Cat(){}.getClass();
        logger.info(anonymous.getCanonicalName());
        logger.info(anonymous.getName());
        logger.info(anonymous.getSimpleName());

        logger.info("-------------- 数组类 --------------");
        Class list = Cat[].class;
        logger.info(list.getCanonicalName());
        logger.info(list.getName());
        logger.info(list.getSimpleName());
    }
}
```

:heavy_check_mark: Output:

```
2022-03-18 14:58:17 - INFO - -------------- 普通类 --------------
2022-03-18 14:58:17 - INFO - com.Reflection.Cat
2022-03-18 14:58:17 - INFO - com.Reflection.Cat
2022-03-18 14:58:17 - INFO - Cat
2022-03-18 14:58:17 - INFO - -------------- 内部类 --------------
2022-03-18 14:58:17 - INFO - com.Reflection.Cat.Head
2022-03-18 14:58:17 - INFO - com.Reflection.Cat$Head
2022-03-18 14:58:17 - INFO - Head
2022-03-18 14:58:17 - INFO - -------------- 匿名类 --------------
2022-03-18 14:58:17 - INFO - null
2022-03-18 14:58:17 - INFO - com.Reflection.ReflectionClassDemo$1
2022-03-18 14:58:17 - INFO - 
2022-03-18 14:58:17 - INFO - -------------- 数组类 --------------
2022-03-18 14:58:17 - INFO - com.Reflection.Cat[]
2022-03-18 14:58:17 - INFO - [Lcom.Reflection.Cat;
2022-03-18 14:58:17 - INFO - Cat[]
```

**总结**:

> * 除了**内部类**、**匿名类**和**数组**外，`getCanonicalName()`,`getName()`相同。
> * **数组**中`getName()`通过`[L`表示数组，`getCanonicalName()`通过在定义的类型后面加上`[]`表示数组
> * **匿名类**中，因为匿名类在java语言规范中是不能呈现出类结构的，它的位置不能通过名称表示出来，所以`getCanonicalName()`方法返回的是`null`，`getName()`返回通过$后面加上迭代数表示。
> * `getSimpleName()`是去掉`getCanonicalName()`返回结果前面的包部分

### 3.3 接口相关

:page_facing_up: Code:

```java
public class ReflectionClassDemo {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Test // Class 类
    public void testClassInterfaces(){
        logger.info("-------------- 判断是否为接口 --------------");
        logger.info("Is Cat an interface: "+Cat.class.isInterface());
        logger.info("Is T1 an interface: "+T1.class.isInterface());
        logger.info("-------------- 获取类实现的接口 --------------");
        for(Class iC : Cat.class.getInterfaces()){
            logger.info(iC.toString());
        }
    }
}
```

:heavy_check_mark: Output:

```
2022-03-18 15:29:11 - INFO - -------------- 判断是否为接口 --------------
2022-03-18 15:29:11 - INFO - Is Cat an interface: false
2022-03-18 15:29:11 - INFO - Is T1 an interface: true
2022-03-18 15:29:11 - INFO - -------------- 获取类实现的接口 --------------
2022-03-18 15:29:11 - INFO - interface com.Reflection.T1
2022-03-18 15:29:11 - INFO - interface com.Reflection.T2
```

### 3.4 其他

:page_facing_up: Code:

```java
public class ReflectionClassDemo {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Test
    public void testClassSuper() {
        logger.info("-------------- 获取父类 --------------");
        logger.info("Cat的父类: "+Cat.class.getSuperclass());
        logger.info("-------------- 获取字段 --------------");
        for(Field f: Cat.class.getFields()){
            logger.info(f.toString());
        }
        logger.info("-------------- 获取构造函数 --------------");
        for(Constructor c: Cat.class.getConstructors()){
            logger.info(c.toString());
        }
        logger.info("-------------- 获取方法 --------------");
        for(Method m: Cat.class.getDeclaredMethods()){
            logger.info(m.toString());
        }
    }
}
```

:heavy_check_mark: Output:

```
2022-03-18 16:18:10 - INFO - -------------- 获取父类 --------------
2022-03-18 16:18:10 - INFO - Cat的父类: class com.Reflection.Animal
2022-03-18 16:18:10 - INFO - -------------- 获取字段 --------------
2022-03-18 16:18:10 - INFO - public int com.Reflection.Cat.cVarPublic
2022-03-18 16:18:10 - INFO - public int com.Reflection.Cat.cVarStaticPublic
2022-03-18 16:18:10 - INFO - public int com.Reflection.Animal.aVarPublic
2022-03-18 16:18:10 - INFO - public int com.Reflection.Animal.aVarStaticPublic
2022-03-18 16:18:10 - INFO - public int com.Reflection.Organism.var
2022-03-18 16:18:10 - INFO - -------------- 获取构造函数 --------------
2022-03-18 16:18:10 - INFO - public com.Reflection.Cat()
2022-03-18 16:18:10 - INFO - public com.Reflection.Cat(int,int)
2022-03-18 16:18:10 - INFO - -------------- 获取方法 --------------
2022-03-18 16:18:10 - INFO - public int com.Reflection.Cat.getcVarPrivate()
2022-03-18 16:18:10 - INFO - public void com.Reflection.Cat.setcVarPrivate(int)
2022-03-18 16:18:10 - INFO - public void com.Reflection.Cat.setcVarStaticPrivate(int)
2022-03-18 16:18:10 - INFO - public int com.Reflection.Cat.getcVarStaticPrivate()
```

## 4 Constructor 类

> Constructor provides information about, and access to, a single constructor for a class.
>
> 构造函数提供有关类的构造函数的信息和访问权。



### 4.1 获取`Constructor`对象

通过`Class`类中的方法获取 `Constructor` 对象:

| 方法名                                                     | 说明                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `Class.getConstructor(Class<?>... parameterTypes)`         | 返回一个`Constructor`对象，该对象反映由这个`Class`对象表示的类的**指定公共**构造函数。 |
| `Class.getConstructors()`                                  | 返回一个包含`Constructor`对象的数组，该对象反映由这个`class`对象表示的类的所有**公共**构造函数。 |
| `Class.getDeclaredConstructor(Class<?>... parameterTypes)` | 返回一个`Constructor`对象，该对象反映由这个`Class`对象表示的类的指定(包含**私有**)构造函数。 |
| `Class.getDeclaredConstructors()`                          | 返回一个包含`Constructor`对象的数组，该对象反映由这个`class`对象表示的类的所有(包含**私有**)构造函数。 |

### 4.2 `Constructor`类的方法：

